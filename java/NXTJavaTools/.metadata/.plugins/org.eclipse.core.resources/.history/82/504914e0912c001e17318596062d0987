package main;

import java.util.List;

import javax.usb.*;

import objects.NXT;

public class Main {
	//important stuff first (idk what to call it)
	
	static final byte nullTerminator = 0x00;//NXT's null thing... ya know... right?
	
	//byte 0 protocalls from the manual:
	
	// DIRECTC REPLY REQUIRED
	// Direct command to the NXT where a reply is required
	// This instruction is used for direct communication with the NXT
	// Commands such as data streams, sensors, and motor commands
	static final byte DIRECTC_REPLY_REQUIRED = 0x00;
	// SYSTEMC REPLY REQUIRED
	// System command to the NXT where a reply is required
	// This instruction is used for system calls with the NXT
	// Commands such as reading/writing files, getting file data, etc.
	static final byte SYSTEMC_REPLY_REQUIRED = 0x01;
	// REPLY COMMAND
	// return value used by the NXT when recieveing information
	// Any data following this is data called from the NXT
	static final byte REPLY_COMMAND = 0x02;
	
	static final byte DIRECTC_SET_OUTPUT_STATE_MOTOR = 0x04;
	static final byte DIRECTC_SET_OUTPUT_STATE_SENSOR = 0x07;
	
	static final byte DIRECTC_REPLY_NOT_REQUIRED = (byte) 0x80;
	static final byte SYSTEMC_REPLY_NOT_REQUIRED = (byte) 0x81;
	
	//chatGPT generated list of commands (dont use yet):
	
	static final byte START_PROGRAM = (byte) 0x00;
	
	
	//commands for things (?)
	
	
	//ports
	static final byte PORT_1 = 0x01;
	static final byte PORT_2 = 0x02;
	static final byte PORT_3 = 0x03;
	static final byte PORT_4 = 0x04;
	
	//data return types for sensors:
	
	static final byte SENSOR_DATA_READ_ALL_AVAILABLE = 0x00;
	
	//The NXT will return a value when soething finishes.
	//0 is what is expected, but anything above that is an issue
	//These are the return values:
	static final byte ERROR_MSG_SUCCESS  					= (byte) 0x00;
	static final byte ERROR_MSG_NO_MORE_HANDLES  			= (byte) 0x81;
	static final byte ERROR_MSG_NO_SPACE  					= (byte) 0x82;
	static final byte ERROR_MSG_NO_MORE_FILES				= (byte) 0x83;
	static final byte ERROR_MSG_END_OF_FILE_EXPECTED  		= (byte) 0x84;
	static final byte ERROR_MSG_END_OF_FILE  				= (byte) 0x85;
	static final byte ERROR_MSG_NOT_A_LINEAR_FILE 			= (byte) 0x86;
	static final byte ERROR_MSG_FILE_NOT_FOUND 				= (byte) 0x87;
	static final byte ERROR_MSG_HANDLE_ALL_READY_CLOSED 	= (byte) 0x88;
	static final byte ERROR_MSG_NO_LINEAR_SPACE 			= (byte) 0x89;
	static final byte ERROR_MSG_UNDEFINED_ERROR 			= (byte) 0x8A;
	static final byte ERROR_MSG_FILE_IS_BUSY 				= (byte) 0x8B;
	static final byte ERROR_MSG_NO_WRITE_BUFFERS 			= (byte) 0x8C;
	static final byte ERROR_MSG_APPEND_NOT_POSSIBLE 		= (byte) 0x8D;
	static final byte ERROR_MSG_FILE_IS_FULL 				= (byte) 0x8E;
	static final byte ERROR_MSG_FILE_EXISTS 				= (byte) 0x8F;
	static final byte ERROR_MSG_MODULE_NOT_FOUND			= (byte) 0x90;
	static final byte ERROR_MSG_OUT_OF_BOUNDARY				= (byte) 0x91;
	static final byte ERROR_MSG_ILLEGAL_FILE_NAME			= (byte) 0x92;
	static final byte ERROR_MSG_ILLEGAL_HANDLE				= (byte) 0x93;
	
	

	public static void main(String[] args) throws SecurityException, UsbException {
		//create connection with the brick
		//ask it for the firmware version
		//????
		//profit
		System.out.println("Getting things...");
		UsbServices usbServices = UsbHostManager.getUsbServices();
		UsbHub rootHub = usbServices.getRootUsbHub();
		List<Object> usbList = rootHub.getAttachedUsbDevices();
		for (Object object : usbList) {
			System.out.println(object.toString());
		}
		
	}
	
	public static void startMotor(byte port, byte power, byte regulationMode, int turnRatio) {
		byte[] motorComand = new byte[] {
			DIRECTC_SET_OUTPUT_STATE_MOTOR,
			port,
			power,
			1,
			regulationMode,
			0,//turn ratio, ignored for single motor
			0x01,//run state
			0
		};
	}

}
